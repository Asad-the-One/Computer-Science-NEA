# --------------------
# CORE CLASSES
# --------------------

# This file contains the main classes for the game. This is imported into "main.py".
# This is done for the sake of maintainability.

# Module imports
import json
import core_algorithms
import os
import pygame
import random
import math

#####################

# Maze class

class Maze:
    
    # Initialise attributes.
    def __init__(self):

        self.maze = {}
    
    # Load a maze from a specified JSON
    def load_maze(self, file_name):

        with open(f"./mazes/{file_name}.json", "r") as f:
            self.maze = json.load(f)

    # Generate a maze and save it.
    def generate_maze(self, file_name, num_rows, num_cols):
        
        # Generate the maze.
        maze = core_algorithms.generate_maze(num_rows, num_cols)
        
        # Convert it into JSON format.
        dict_maze = {}
        for i in range(len(maze)):
            dict_maze[str(i)] = {}
            for o in range(len(maze[i])):
                dict_maze[str(i)][str(o)] = {
                        "wall": maze[i][o],
                        "discovered": False
                        }
        
        # Make this new maze the object's maze.
        self.maze = dict_maze

        # Ensure the directory "mazes" exists for storing mazes.
        if "mazes" not in os.listdir():
            print("Directory 'mazes' does not exist. Creating...")
            os.mkdir("mazes")

        with open(f"./mazes/{file_name}.json", "w") as f:
            json.dump(self.maze, f, indent=4)

    # Render the maze as 0s and spaces in the terminal.
    def terminal_output(self, walls=False):
        
        output_arr = []
        # Turn the maze dictionary into a 2D array.
        # For each row:
        for i in self.maze:
            
            # Temp variable to be appended to the output array.
            temp = []

            # For each column:
            for o in self.maze[i]:
                
                # Append 1 or 0 (wall or path) to temp.
                temp.append(self.maze[i][o]["wall"])
            
            # Append temp to the output array, then reset it to empty on the next iteration.
            output_arr.append(temp)
        
        # Iterate through the output array and print only the 0s with spaces between them.
        for i in output_arr:

            temp = str(i).replace("[", "")
            temp = temp.replace("]", "")
            temp = temp.replace(",", "")
            if walls:
                temp = temp.replace("0", " ")
            else:
                temp = temp.replace("1", " ")
            print(temp)
            
#####################

# Player class

class Player(pygame.sprite.Sprite):
    
    # Initialise attributes.
    def __init__(self, pos, rect, screen_pos=[640,360], inventory=[], keybinds={}, echo_cool=0, speed_buff=False, health=10, max_health=10, speed=5):
        super().__init__()
        self.rect = rect

        self.pos = pos
        self.screen_pos = screen_pos        
        self.inventory = inventory
        self.keybinds = keybinds
        self.echo_cool = echo_cool
        self.speed_buff = speed_buff
        self.health = health
        self.max_health = max_health
        self.speed = speed
    
    # Echolocation
    def echolocation(self): # Will add attributes in a future sprint
        # Reveal tiles ahead
        self.echo_cool = 20

#####################

# Enemy class
# Types of enemy will inherit from this base class if they have special abilities, which I may implement near the end of development if I have time.

class Enemy(pygame.sprite.Sprite):

    # Initialise attributes.
    def __init__(self, pos, rect, attack=2, speed=2, sense_strength=(0.1,0.1), loot=[]):
        super().__init__()
        self.pos = pos
        self.attack = attack
        self.speed = speed
        self.sense_strength = sense_strength
        self.loot = loot
        self.path = []

        #self.rect = self.image.get_rect(center=(int(pos[0]), int(pos[1])))
        self.rect = rect
    
    # Deal damage
    def deal_damage(self, player):
        # if touching player
        #   reduce player.health by self.attack
        #   cooldown 1 second
        pass

    # A* pathfinding
    def astar(self, maze):
        # A* algorithm returning a path to trace back up
        pass

    # Update enemy position
    def update_position(self):
        # Use self.path and self.speed to move the enemy if necessary
        pass

#####################

# Chest class

class Chest(pygame.sprite.Sprite):

    # Initialise object
    def __init__(self, pos, rect, loot=[]):
        super().__init__()
        self.loot = loot
        self.pos = pos
        self.rect = rect

    # Open chest
    def open_chest(self):
        # Drop all items at the current tile
        # Despawn
        pass

#####################

# Wall class

class Wall(pygame.sprite.Sprite):

    # Initialise object
    def __init__(self, pos, rect):
        super().__init__()
        self.pos = pos
        self.rect = rect

#####################

# Camera class

class Camera:

    # Initialise object
    def __init__(self, tile_size):

        self.pos = [0,0]
        self.ease = 0.15
        self.tile_size = tile_size
        self.x_offset = 0
        self.y_offset = 0

    # Update view of the map
    def update(self, target, screen_dimensions, scale):

        # Get mouse coordinates
        mouse_coords = list(pygame.mouse.get_pos())
        mouse_coords[0] -= screen_dimensions[0]//2
        mouse_coords[1] -= screen_dimensions[1]//2

        # Sensitivity
        sens = 0.5

        # Set x and y offsets
        self.x_offset = sens * -math.tanh(mouse_coords[0]*0.001)
        self.y_offset = sens * -math.tanh(mouse_coords[1]*0.001)
        
        # Move camera with ease to the target location
        self.pos[0] += (target[0] - screen_dimensions[0]/(2*scale) - self.pos[0]) * self.ease
        self.pos[1] += (target[1] - screen_dimensions[1]/(2*scale) - self.pos[1]) * self.ease

#####################

# Game class

class Game:

    # Initialise object.
    def __init__(self, maze, tile_size=50, window_width=1280, window_height=720):
        
        self.maze = maze.maze
        self.running = True
        pygame.init()

        self.clock = pygame.time.Clock()
        self.clock.tick(1)
        self.camera = Camera(tile_size)

        self.direction = {
            "u": False,
            "d": False,
            "l": False,
            "r": False
        }
        self.screen_dimensions = [window_width, window_height]
        
        self.walls = pygame.sprite.Group()
        self.chests = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.check_sprite_collisions = pygame.sprite.Group()
        
        # Give the window the name "Sonar's Edge".
        pygame.display.set_caption("Sonar's Edge")

        self.spawn_enemies(100)
        self.spawn_chests(50)
        
        self.screen = pygame.display.set_mode((window_width, window_height), pygame.FULLSCREEN|pygame.SCALED)


    # Handle running the game
    def run(self, player_speed=0.05):
        
        # Make game run at 60fps
        tick = self.clock.tick(60) / 1000
        rect = pygame.Rect(
            0,
            0,
            self.camera.tile_size,
            self.camera.tile_size
        )
        self.player = Player([0, 0], rect, speed=player_speed)

        # Add walls to the wall group
        y = 0
        rect = pygame.Rect(
            0,
            0,
            self.camera.tile_size,
            self.camera.tile_size
        )
        for row in self.maze:

            for col in self.maze[row]:
                cell = self.maze[row][col]
                x, y = float(col), float(row)

                if cell["wall"]:
                    rect.x = (x-self.camera.pos[0]) * self.camera.tile_size
                    rect.y = (y-self.camera.pos[1]) * self.camera.tile_size
                    rect.center = (rect.x, rect.y)
                    self.walls.add(Wall([x, y], rect))
        
        # Run the game
        while self.running:
 
            # Process pygame events
            for event in pygame.event.get():

                # Quit if the user wants to quit
                if event.type == pygame.QUIT:
                    self.running = False
                
                # Process key presses. Will implement keybinds later. For now, just WASD.
                if event.type == pygame.KEYDOWN:

                    # W
                    if event.key == pygame.K_w:
                        self.direction["u"] = True
                    # A
                    if event.key == pygame.K_a:
                        self.direction["l"] = True                    
                    # S
                    if event.key == pygame.K_s:
                        self.direction["d"] = True                    
                    # D
                    if event.key == pygame.K_d:
                        self.direction["r"] = True
                
                # Process key lifts. Will implement keybinds later. For now, just WASD.
                if event.type == pygame.KEYUP:

                    # W
                    if event.key == pygame.K_w:
                        self.direction["u"] = False
                    # A
                    if event.key == pygame.K_a:
                        self.direction["l"] = False                    
                    # S
                    if event.key == pygame.K_s:
                        self.direction["d"] = False                    
                    # D
                    if event.key == pygame.K_d:
                        self.direction["r"] = False
            
            # Draw the maze
            self.draw_maze()

            # Update screen
            pygame.display.flip()
    
    # Spawn enemies randomly around path cells
    def spawn_enemies(self, count):

        # Get maze dimensions
        maze_dimensions = (len(self.maze)-1, len(self.maze["0"])-1)

        # Continue spawning enemies until count is 0
        rect = pygame.Rect(
            0,
            0,
            self.camera.tile_size,
            self.camera.tile_size
        )
        while count > 0:

            # Get a random row and column
            row = str(random.randint(0, maze_dimensions[0]))
            column = str(random.randint(0, maze_dimensions[1]))

            # Add an enemy if the cell is a path cell
            if not self.maze[row][column]["wall"]:
                count -= 1
                x, y = float(column), float(row)
                self.enemies.add(Enemy([x, y], rect))

                rect.x = (x-self.camera.pos[0]) * self.camera.tile_size
                rect.y = (y-self.camera.pos[1]) * self.camera.tile_size
                rect.center = (rect.x, rect.y)
                self.walls.add(Wall([x, y], rect))
    
    # Spawn chests randomly around path cells
    def spawn_chests(self, count):

        # Get maze dimensions
        maze_dimensions = (len(self.maze)-1, len(self.maze["0"])-1)

        # Continue spawning chests until count is 0
        rect = pygame.Rect(
            0,
            0,
            self.camera.tile_size,
            self.camera.tile_size
        )
        while count > 0:

            # Get a random row and column
            row = str(random.randint(0, maze_dimensions[0]))
            column = str(random.randint(0, maze_dimensions[1]))

            # Add a chest if the cell is a path cell
            if not self.maze[row][column]["wall"]:
                count -= 1
                x, y = float(column), float(row)
                rect.x = (x-self.camera.pos[0]) * self.camera.tile_size
                rect.y = (y-self.camera.pos[1]) * self.camera.tile_size
                rect.center = (rect.x, rect.y)
                self.chests.add(Chest([x, y], rect))
    
    # Determine dx and dy, then apply it to the player on each game tick.
    def draw_maze(self):

        self.screen.fill((75,75,75))

        dx = dy = 0
        
        # Update dy
        if self.direction["u"]:
            dy = -self.player.speed
        if self.direction["d"]:
            dy = self.player.speed

        # Update dx
        if self.direction["l"]:
            dx = -self.player.speed
        if self.direction["r"]:
            dx = self.player.speed
        
        # Clear differences if conflicts
        if self.direction["u"] and self.direction["d"]:
            dy = 0
        if self.direction["r"] and self.direction["l"]:
            dx = 0
        
        # Check for any collisions
        dx, dy = self.check_collisions(dx, dy)

        # Move player
        self.player.pos[0] += dx
        self.player.pos[1] += dy
        self.player.rect.center = self.player.pos

        # Move camera
        self.camera.update(
            self.player.pos,
            self.screen_dimensions,
            self.camera.tile_size
        )

        #### Render sprites
        cam_x, cam_y = self.camera.pos
        x_offset, y_offset = self.camera.x_offset, self.camera.y_offset
        tile_size = self.camera.tile_size

        # Clear collision checking group
        self.check_sprite_collisions = pygame.sprite.Group()

        # Move the rest of the sprites
        
        for wall in self.walls:
            
            rect = pygame.Rect(
                (wall.pos[0]-cam_x+x_offset)*tile_size,
                (wall.pos[1]-cam_y+y_offset)*tile_size,
                tile_size,
                tile_size
            )
            wall.rect = rect
            pygame.draw.rect(self.screen, (0,0,0), rect)

            # Check if in screen bounds
            if 0 < rect.x < self.screen_dimensions[1] and 0 < rect.y < self.screen_dimensions[1]:
                self.check_sprite_collisions.add(wall)        

        # Render player
        length = self.camera.tile_size/3
        rect = pygame.Rect(
                (self.player.pos[0]-cam_x+x_offset)*tile_size,
                (self.player.pos[1]-cam_y+y_offset)*tile_size,
                length,
                length
            )
        rect.center = (rect.x, rect.y)
        self.player.rect = rect
        
        #pygame.draw.rect(self.screen, (255,255,255), rect)
        pygame.draw.circle(self.screen, (0,0,255), (self.player.rect.x+length/2, self.player.rect.y+length/2), length/2 - length*self.player.speed/2)

        pygame.display.update()
    
    # Check collisions, then apply changes to movement deltas
    def check_collisions(self, dx, dy):

        for sprite in self.check_sprite_collisions:
            if not self.player.rect.colliderect(sprite.rect):
                self.check_sprite_collisions.remove(sprite)
        
        for sprite in self.check_sprite_collisions:

            # Check if x movement needs to be cleared
            # Player Wall
            if sprite.rect.collidepoint(self.player.rect.midright) and dx >= 0:
                dx = 0
            # Wall Player
            elif sprite.rect.collidepoint(self.player.rect.midleft) and dx <= 0:
                dx = 0

            # Check if y movement needs to be cleared
            # Wall under player
            if sprite.rect.collidepoint(self.player.rect.midbottom) and dy >= 0:
                dy = 0
            # Wall over player
            elif sprite.rect.collidepoint(self.player.rect.midtop) and dy <= 0:
                dy = 0
        
        return dx, dy
